
## **Create Tables (David johansson)**

<font color="red">

  - Map each entity and relationship to proper tables.

  - Document the schema details in your report.
</font>

<font color="green">

the Player table creates and stores the player. Each player can control a character that is identified via a name and username. The table is linked to the Character table through the foreign key. The table consists of the following: 
PlayerID: and Int identifies each player and is the primary key
Name: A string consists of the full name of the player
UserName: a string that contains the player's username. All usernames must be unique 
CharacterID: An int that is also a foreign key which links to the character table 

CREATE TABLE Player ( PlayerID INT PRIMARY KEY,
Name VARCHAR(255),
UserName VARCHAR(255),
CharacterID INT,
FOREIGN KEY (CharacterID) REFERENCES Character(CharacterID) );
CREATE TABLE Character (
CharacterID INT PRIMARY KEY,
Name VARCHAR(255),
Level INT,
XP INT,
HP INT,
Mana INT,
Alignment VARCHAR(255),
charClassID INT,
charRaceID INT,
FOREIGN KEY (charClassID) REFERENCES Class(ClassID),
FOREIGN KEY (charRaceID) REFERENCES Race(RaceID) );
 
The Class table is used to store different character classes that are available for players. The table consists of the following:
ClassID: a primary key that uniquely identifies each class available
ClassName: a varchar that names each class
HitDie: an Int that is used as a die for HP calculation
PrimaryStat: a VarChar that shows the main stat for each class
Description:  a text field providing details about each class


CREATE TABLE Class (
ClassID INT PRIMARY KEY,
ClassName VARCHAR(255),
HitDie INT,
PrimaryStat VARCHAR(255),
Description TEXT );
CREATE TABLE Race (
RaceID INT PRIMARY KEY,
RaceName VARCHAR(255),
BonusStat VARCHAR(255),
Description TEXT
);

 
The Race table consists of data about each character's race. The table contains the following data:
RaceID: The primary key that uniquely identifies each available race 
RaceName: A varchar that names each race
BonusStat a Varchar that shows the benefits of each race
Description: a Text field that contains contextual background information for each race.

CREATE TABLE Race (
RaceID INT PRIMARY KEY,
RaceName VARCHAR(255),
BonusStat VARCHAR(255),
Description TEXT
);
 
The Spell table stores available spells and contains the following data:
SpellID: A primary key that uniquely identifies each spell available 
Name: a Varchar that contains the name of each spell
Level: An Int that shows the level of each spell
School: a Varchar indicating which magical school the spell is part of
Effect: a text field describing the capabilities of each spell
CastingTime: a Varchar that contains the duration of casting time of each spell
Duration: a Varchar that consists of how long the effects of the particular spell are expected to last
 

CREATE TABLE Spell (
SpellID INT PRIMARY KEY,
Name VARCHAR(255),
Level INT,
School VARCHAR(255),
Effect TEXT,
CastingTime VARCHAR(255),
Duration VARCHAR(255)
);


 
 The ClassSpell table stores the relationship between class and spell and contains the following data: 
ClassID: An Int that stores what class the spell belongs to
SpellID: uniquely  identifies each spell.

CREATE TABLE ClassSpell (
ClassID INT,
SpellID INT,
PRIMARY KEY (ClassID, SpellID),
FOREIGN KEY (ClassID) REFERENCES Class(ClassID),
FOREIGN KEY (SpellID) REFERENCES Spell(SpellID)
);
 
The Monster table stores enemy data “monster” and contains the following:
MonsterID: the primary key uniquely identifying each monster
Name: A varchar containing each monster's name
RaceID: the foreign key that points to Race.RaceID
ClassID: a foreign key which points to Class.classID
CR: a Float that contains difficulty level
HP: an Int containing health 
AC: an Int showing armor class
Type: a Varchar describing class/type of monster 
XP: a varchar showing how much XP is given after defeating said monster. 

CREATE TABLE Monster (
MonsterID INT PRIMARY KEY,
Name VARCHAR(255),
RaceID INT,
ClassID INT,
CR FLOAT,
HP INT,
AC INT,
Type VARCHAR(255),
XP INT,
FOREIGN KEY (RaceID) REFERENCES Race(RaceID),
FOREIGN KEY (ClassID) REFERENCES Class(ClassID)
);
 
The Boss contains data on different bosses encountered throughout the game.
BossID: The primary key uniquely identifying each boss
Name: a Varchar that contains the name of each boss
MonsterID: a foreign key pointing to Monster MonsterID
PhaseCount: An Int showing the level of phases a boss has
Lair: A Varchar for the location of each boss.

CREATE TABLE Boss (
BossID INT PRIMARY KEY,
Name VARCHAR(255),
MonsterID INT,
PhaseCount INT,
Lair VARCHAR(255),
FOREIGN KEY (MonsterID) REFERENCES Monster(MonsterID)
);
 
The Equipment table contains all items that are attainable for players in the game. It contains the following data:
EquipmentID: the primary key that uniquely identifies each item. 
Name: a Varchar that contains the name of each item
Type: A varchar that contains the category of item
Bonus: A Varchar that contains bonus items
Rarity: A Varchar that displays the rarity of each item
Description: a Text field that explains what each item is and what it does

CREATE TABLE Equipment (
EquipmentID INT PRIMARY KEY,
Name VARCHAR(255),
Type VARCHAR(255),
Bonus VARCHAR(255),
Rarity VARCHAR(255),
Description TEXT );
 
The CharacterEquipment table shows what equipment belongs to what character. It contains the following:
CharactherID: a foreign key referencing Character.CharactherID
EquipmentID a foreign key referencing Characther.CharactherID 

CREATE TABLE CharacterEquipment ( CharacterID INT,
EquipmentID INT,
PRIMARY KEY (CharacterID, EquipmentID),
FOREIGN KEY (CharacterID) REFERENCES Character(CharacterID),
FOREIGN KEY (EquipmentID) REFERENCES Equipment(EquipmentID)
);
 
The NPC table contains the non-playable characters present in the game. It contains the following data:
NPCID: the primary key uniquely identifying each NPC
Name: a Varchar containing the name of each NPC
Role: A Varchar displaying the role of each NPC such as guard, merchant etc.
Faction: the “guild” each NPC belongs to
Location: The location of each NPC
 

CREATE TABLE NPC (
NPCID INT PRIMARY KEY,
Name VARCHAR(255),
Role VARCHAR(255),
Faction VARCHAR(255),
Location VARCHAR(255)
);
 
The Event table tracks all events in the game. It contains the following data:
EventID: The primary key uniquely identifying each event.
Name: a Varchar which names each event
Date: a Date which shows when the event occurred
Description: A text field explaining the event that occurred.

CREATE TABLE Event (
EventID INT PRIMARY KEY,
Name VARCHAR(255),
Date DATE,
Description TEXT
);
 
The CharacterEvent table stores all events specific players have participated in. It contains the following:
CharacterID: a foreign key referencing character.charactherID
EventID: a foreign key referencing    EventID 

CREATE TABLE CharacterEvent (
CharacterID INT,
EventID INT,
PRIMARY KEY (CharacterID, EventID),
FOREIGN KEY (CharacterID) REFERENCES Character(CharacterID),
FOREIGN KEY (EventID) REFERENCES Event(EventID)
);
 
The Achievement table stores all achievements players can accomplish throughout the game. It contains the following:
AchievementID: The primary key uniquely identifying each achievement 
Name: a Varchar that names each achievement 
Description: A text field that describes how players can earn said achievement  
XPReward: An Int which shows the experience awarded for each achievement 


CREATE TABLE Achievement (
AchievementID INT PRIMARY KEY,
Name VARCHAR(255),
Description TEXT,
XPReward INT );
 
The PlayerAchievement table stores data referencing which player has been able to complete which achievement. It contains the following:
PlayerID A foreign key referencing Player.PlayerID
AchievementID:A foreign key  referencing Achievement.AchievementID
 
 
CREATE TABLE PlayerAchievement ( PlayerID INT,
AchievementID INT,
PRIMARY KEY (PlayerID, AchievementID),
FOREIGN KEY (PlayerID) REFERENCES Player(PlayerID),
FOREIGN KEY (AchievementID) REFERENCES Achievement(AchievementID)
);





</font>
## **Insert Sample Data (David johansson)**

<font color="green">

**This is an example of Values being added to associated table**

  INSERT INTO Plant

    VALUES(100, "Sagali", "Texas", "Mining"),

          (200, "Tema", "Atlanta", "Refinery"),

          (300, "Mashda", "New York", "Cannary"),

          (400, "Segal", "Washington", "Mixer"),

          (500, "Pinto", "Pensacola", "Grinder");

</font>

<font color="red">

  - Populate each table with at least five records.

  - Include a snapshot of the data entries in your submission.

</font>

## **Write & Execute Complex Queries(David johansson)**

(Formulate and run at least five meaningful SQL queries that involve 3–4 table joins.)

<font color="red">

* Ensure all tables are actively used—none should be redundant.

* For each query:

     + **Describe the goal in plain English**

     + Show the SQL code.

     + **Present the query results** - NOTE will add after init_database.py is completed

</font>

### Lists all Characters with their class, race, and equiment


<font color="green">

Need a reason or story for the use of this query: i.e.

quote from demo paper

"
A customer reported that his company fired him for purchasing a bad product from us. The qualitycontrol manager analysed the situation and suggested the product might have been produced usingmaterials of less time life. Hence, we want to find all products and their related materials producedfor this situation.
"

</font>

```
    SELECT 
        c.Name AS CharacterName,
        cl.ClassName,
        r.RaceName,
        e.Name AS EquipmentName,
        e.Type AS EquipmentType,
        e.Bonus
    FROM Character c
    JOIN Class cl ON c.charClassID = cl.ClassID
    JOIN Race r ON c.charRaceID = r.RaceID
    JOIN CharacterEquipment ce ON c.CharacterID = ce.CharacterID
    JOIN Equipment e ON ce.EquipmentID = e.EquipmentID
    WHERE e.Equipped = TRUE
    ORDER BY c.Name, e.Name;
```

| CharacterName | ClassName | RaceName |EquipmentName | EquipmentType  | Bonus                         |
|---------------|-----------|----------|--------------|----------------|-------------------------------|
| name 1        |  wizard   | High elf | Blight caller| sword          |None                           |

### Finds all spells available to a character 

```
    SELECT 
        c.Name AS CharacterName,
        cl.ClassName,
        s.Name AS SpellName,
        s.Level,
        s.School
    FROM Character c
    JOIN Class cl ON c.charClassID = cl.ClassID
    JOIN ClassSpell cs ON cl.ClassID = cs.ClassID
    JOIN Spell s ON cs.SpellID = s.SpellID
    ORDER BY c.Name, s.Level;
```

| CharacterName | ClassName | SpellName |Level | school     |
|---------------|-----------|-----------|------|------------|
| name 1        |  wizard   | Fire ball |  5 | Fire         |                  


### Lists all players and what events they have participated in.

```
    SELECT
        p.UserName,
        c.Name AS CharacterName,
         e.Name AS EventName,
        e.Date AS EventDate
    FROM Player p
    JOIN PlayerCharacter pc ON p.PlayerID = pc.PlayerID
    JOIN Character c ON pc.CharacterID = c.CharacterID
    JOIN CharacterEvent ce ON c.CharacterID = ce.CharacterID
    JOIN Event e ON ce.EventID = e.EventID
    ORDER BY p.UserName, e.Date DESC;
```

| UserName | CharacterName |EventName |EventDate |
|----------|-----------|-----------------------|---------------|
| Michael  |  Parzival | "The Great Key Chase" |  '2025-01-01' |      

### Average level of XP per class

```
    SELECT
        cl.ClassName,
        AVG(c.Level) AS AvgLevel,
        SUM(c.XP) AS TotalXP
    FROM Character c
    JOIN Class cl ON c.charClassID = cl.ClassID
    GROUP BY cl.ClassName
    ORDER BY AvgLevel DESC;
```

### won battles by character

```
    SELECT
        c.Name AS CharacterName,
        COUNT(DISTINCT e.EventID) AS BattlesWon
    FROM Character c
    JOIN CharacterEvent ce ON c.CharacterID = ce.CharacterID
    JOIN Event e ON ce.EventID = e.EventID
    WHERE e.Type = 'Battle'
    AND e.Result = 'Won'
    GROUP BY c.Name
    ORDER BY BattlesWon DESC;

```

## **Show Reverse-Engineered Diagram (Michael Zeihen) **

  - Use reverse engineering to visualize the implemented schema.

  - Add the generated ER diagram to your report to confirm alignment between design and implementation.

